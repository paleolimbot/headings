% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/heading-density.R
\name{hdg_density}
\alias{hdg_density}
\alias{plot.hdg_density}
\alias{hdg_plot}
\title{Heading-aware kernel density}
\usage{
hdg_density(
  hdg,
  bw = 5,
  kernel = c("gaussian", "epanechnikov", "rectangular", "triangular", "biweight",
    "cosine", "optcosine"),
  weights = NULL,
  n = 512,
  na.rm = FALSE,
  ...
)

\method{plot}{hdg_density}(x, main = NULL, xlab = NULL, ylab = NULL, axes = TRUE, ...)

hdg_plot(
  hdg,
  density = hdg_density(hdg, na.rm = TRUE),
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  axes = TRUE,
  ...
)
}
\arguments{
\item{hdg}{A heading in degrees, where 0 is north,
90 is east, 180 is south, and 270 is west. Values
outside the range [0-360) are coerced to this range
using \code{\link[=hdg_norm]{hdg_norm()}}.}

\item{bw}{The bandwidth of the smoothing kernel. Automatic methods
are not available, so you will have to set this value manually to
obtain the smoothness you want.}

\item{kernel}{a character string giving the smoothing kernel
    to be used. This must partially match one of \code{"gaussian"},
    \code{"rectangular"}, \code{"triangular"}, \code{"epanechnikov"},
    \code{"biweight"}, \code{"cosine"} or \code{"optcosine"}, with default
    \code{"gaussian"}, and may be abbreviated to a unique prefix (single
    letter).

    \code{"cosine"} is smoother than \code{"optcosine"}, which is the
    usual \sQuote{cosine} kernel in the literature and almost MSE-efficient.
    However, \code{"cosine"} is the version used by S.
  }

\item{weights}{numeric vector of non-negative observation weights,
    hence of same length as \code{x}. The default \code{NULL} is
    equivalent to \code{weights = rep(1/nx, nx)} where \code{nx} is the
    length of (the finite entries of) \code{x[]}.}

\item{n}{the number of equally spaced points at which the density is
    to be estimated.  When \code{n > 512}, it is rounded up to a power
    of 2 during the calculations (as \code{\link[stats]{fft}} is used) and the
    final result is interpolated by \code{\link[stats]{approx}}.  So it almost
    always makes sense to specify \code{n} as a power of two.
  }

\item{na.rm}{logical; if \code{TRUE}, missing values are removed
    from \code{x}. If \code{FALSE} any missing values cause an error.}

\item{...}{For \code{\link[=hdg_density]{hdg_density()}}, dots are unused; for \code{plot.hdg_density()},
dots are passed to \code{\link[graphics:lines]{graphics::lines()}}; for \code{hdg_plot()}, passed to
\code{\link[graphics:points]{graphics::points()}}}

\item{x}{the data from which the estimate is to be computed.  For the
    default method a numeric vector: long vectors are not supported.}

\item{main, xlab, ylab, axes}{See \code{\link[graphics:plot.default]{graphics::plot()}}.}

\item{density}{A \code{\link[=hdg_density]{hdg_density()}} object.}
}
\value{
An object identical to \code{\link[stats:density]{stats::density()}} but with class
"hdg_density".
}
\description{
Computes an approximate density useful for visualization. For proper
circular densities, use \code{\link[=hdg_circular]{hdg_circular()}} and \code{\link[circular:density.circular]{circular::density.circular()}}.
}
\examples{
x <- head(kamloops2016$wind_dir, 1000)
hdg_density(x, na.rm = TRUE)
plot(hdg_density(x, na.rm = TRUE))
hdg_plot(x)

}
